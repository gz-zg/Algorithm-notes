/*
①我们首先可以想到 k=0 情况，那就是对称的构造，也就是 (i,n−1-i) 这么去构造。
②那么若 k≠0 时，我们就想，是否我们可以首先使得一个“对子”直接值为 k ，其余的都为 0 呢。
那么如果要让一对值直接为 k ，那就让 k 直接去 & 上一个全 1 的数就好了，也就是 n − 1 ，
然后我们发现这样的话 k 是不可以为 n−1 的，那么我们就先讨论 k≠n−1的情况。
让 k 与 n−1 成一对之后，我们希望其它对都是 0 ，那么我思考这样操作 k 与 n−1 配对，
在①的构造方式上发生了哪些破坏呢，实际上就是只破坏了 (0,n−1),(k,n−1−k)这个两个对，
那么我们显然可以发现，让 k 和 n−1 配对后，让 0 和 n−1−k 配对就完事了，其它的都保持原构造，这样全局的值就为 k 了。
③那么我们现在就考虑当 k=n−1 时的构造方式，那么我们往简单了想，
能否构造个 n−2 和 1 出来，我们发现是可以的，我们可以形成 (n−1,n−2) 以构造出 n−2 ，
再由(1,n−3)造出 1 ，被破坏的 0 和 2 组合成(0,2)形成，其余的构造如①一样，
这样总和就为 n-2+1=n−1 了，实际上就是在①的基础上，调整(0,n−1)(1,n−2)(2,n−3)的顺序。
当然，我们会发现这样的情况只使用于 n ≥ 4 ，而且我们发现当 n=4 时 k=3 是无解的。
至此我们就考虑完了所有情况。
*/
#include <bits/stdc++.h>
using namespace std;

int n,k;

void solve()
{
    cin>>n>>k;
    if(n==4 && k==3){cout<<-1<<endl; return;}
    if(k==0)
    {
        for(int i=0;i<=n/2-1;i++)
            printf("%d %d\n",i,n-1-i);
    }
    else if(1<=k && k<=n-2)
    {
        printf("%d %d\n",k,n-1);
        printf("%d %d\n",0,n-1-k);
        for(int i=0;i<=n/2-1;i++)
            if(i!=0 && i!=n-1-k && i!=k && i!=n-1)
                printf("%d %d\n",i,n-1-i);
    }
    else if(k==n-1)
    {
        printf("%d %d\n",n-2,n-1);
        printf("%d %d\n",1,n-3);
        printf("%d %d\n",0,2);
        for(int i=0;i<=n/2-1;i++)
            if(i!=0 && i!=2 && i!=1 && i!=n-3 && i!=n-2 && i!=n-1)
                printf("%d %d\n",i,n-1-i);
    }
}

signed main()
{
    int t; cin>>t;
    while(t--)solve();
    return 0;
}